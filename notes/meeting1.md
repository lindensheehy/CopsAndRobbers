next steps:
when it is the cops turn, and there is a robbers turn to play, and we have these nodes (ex. a,a b,b) on both columns. One thing to note that the same nodes are marked in the beggining, so lets say a,c is not marked you mark it if there is one that is marked. and on robbers you mark if there is for all neighbors they are marked then the gut is marked on the right. The robber says I want to avoid losing - so if all of the neighbors of the right column are marked - he loses. We need to consider all possible placements of the cops, so now we will have tripples, so there is position of two cops and one position of the robber (like (a,a), a) so we need to write all possible combinations of positions of the cops and a robber, and in case you dont want this thing to explode you can avoid doing mix matches like (a,b),a and (b,a)a - to make it less (a little optimization that can save a lot). now we will start to care for hidden constant of n^2 for the algorithms. There is a cop (1) at the same position as the robber - so it gets marked (same as previous algorithm). It could be nice to make number of cops a variable and positions should not repeat themselves as mentioned earlier. Write positions of k cops - we could use lexicograph order. If you lexicographicallly sort to get a b (just generate sequences without repetition). It would be nice to start with 2 cops but making a general case for k cops and have 1 robber. 1 robber stays since most graph theory research stays with 1 robber. So more graphs for testing to implement: Graphs with cop number 1: we have paths, we have trees, we dismantlable graphs - it would be important to read about dismntable graphs. SO what is it? First to define that we need to define something elese: so there is a graph G= (V,E) , we take a vertex v —ç V, the neighbor of the vertext N(v) = set of all the neighbors of v, so its everything adjacent, so it is neighborhood, and we have closed neighborhood where N[v] with square brackets N\[v\] = N(v)U{v} so v is a corner of v if N[u] is contained in N[v] so you dont see any vertecies that v is not seeing, so it is over in one move! So what is a dismantable graph where you look at the graph - there is a corner  and you remove it, and then you look again - another corner and you remove it! And if you can keep removing corners and you will be left with 1 vertex in the end - its dismantable. example with paths - if we keep removing it is a dismantable graph! But THE CORNER is where it is "over in one move" so its if and only if to win with 1 cop. So rule is if you want to win with 1 cop - you need it to be dismantable. it could be possible to generate dismantable graph. (reading will be stored locally). Now to verify graphs with cop-number 2: cycles, outerplanar graphs - an outerplanar graph is a cycle with a bunch of connections and shortcuts inside and the shortcuts dont intersect. Some outerplaner graphs have cop number 1!!! So for them it is AT MOST 2 because SOME OF THEM TURN OUT TO BE DISMANTABLE! Cop number is at most 3: planar graphs - so draw nodes so no edges are intersecting and the difference between outerplanar graphs and planar graphs are in outerplanar there are NO verticies in the interior while in planar there could be nodes inside. So again for planar graphs it is AT MOST 3. Now the dodecehodron graph has cop number 3. the peterson graph has cop number 3, and robertson graph has cop number 4. so main plan - fix the algorithm, still keep python, make cop number variable, and add vizualizing option. So schedule wise: wednesday 28th we have an online meeting at 4, February 10th before 11:30 or most probably Friday 13th in person at 4. Picture of scotland yard will be sent at some point during the weekend. 